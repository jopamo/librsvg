#include <config.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#define RSVG_DISABLE_DEPRECATION_WARNINGS
#include "rsvg.h"
#include "test-utils.h"

static void test_metadata_injection(void) {
    const char* svg_content =
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
        "<svg xmlns=\"http://www.w3.org/2000/svg\">"
        "<metadata injection = '&quot; onload=&quot;alert(1)' />"
        "</svg>";

    GError* error = NULL;
    RsvgHandle* handle = rsvg_handle_new_from_data((const guint8*)svg_content, strlen(svg_content), &error);
    g_assert_no_error(error);
    g_assert(handle != NULL);

    const char* metadata = rsvg_handle_get_metadata(handle);
    g_assert(metadata != NULL);

    g_test_message("Metadata: %s", metadata);

    /* Check if the output is malformed/injected */
    /* Expected safe output: injection=\"&quot; onload=&quot;alert(1)\" or similar escaped version */
    /* Vulnerable output: injection=\"\" onload=\"alert(1)\" */

    if (strstr(metadata, "injection=\"\" onload=\"alert(1)\"") != NULL) {
        g_test_fail_printf("Vulnerability confirmed: Metadata injection successful.\nGot: %s", metadata);
    }
    else {
        /* Check if it IS escaped correctly (e.g. &quot;) */
        /* Note: glib might use different escaping or rsvg might not escape at all but use single quotes if smart?
           But the code used "%s=\" %s \" ". Hardcoded double quotes. */
        if (strstr(metadata, "injection=\"&quot;") == NULL && strstr(metadata, "injection=\"&#34;") == NULL) {
            /* If it's not the exact injection string but also not escaped, it might be just broken syntax like
             * injection=\"\"" */
            /* The input value is `" onload="alert(1)` */
            /* The code prints `injection="` + value + `"` */
            /* So `injection=\"\" onload=\"alert(1)\""` */
            char* expected_bad = "injection=\"\" onload=\"alert(1)\"";
            if (strstr(metadata, expected_bad)) {
                g_test_fail_printf("Vulnerability confirmed: %s", metadata);
            }
        }
    }

    g_object_unref(handle);
}

static void test_instancing_limit(void) {
    GString* svg = g_string_new("<svg xmlns=\"http://www.w3.org/2000/svg\">");
    /* The limit in testing mode is 20000 */
    for (int i = 0; i < 20005; i++) {
        g_string_append(svg, "<rect width=\"1\" height=\"1\"/>");
    }
    g_string_append(svg, "</svg>");

    GError* error = NULL;
    RsvgHandle* handle = rsvg_handle_new();
    rsvg_handle_internal_set_testing(handle, TRUE);

    if (rsvg_handle_write(handle, (const guint8*)svg->str, svg->len, &error)) {
        rsvg_handle_close(handle, &error);
    }

    /* This should fail because it exceeds the loading limit */
    g_assert_nonnull(error);
    g_assert(g_error_matches(error, RSVG_ERROR, 0));
    g_assert_cmpstr(error->message, ==, "instancing limit");

    g_object_unref(handle);
    g_string_free(svg, TRUE);
    g_clear_error(&error);
}

static void test_css_size_limit(void) {
    size_t size = 1024 * 1024 + 100;
    char* css = g_malloc(size);
    memset(css, ' ', size);
    css[size - 1] = '\0';

    GString* svg = g_string_new("<svg xmlns=\"http://www.w3.org/2000/svg\"><style>");
    g_string_append(svg, css);
    g_string_append(svg, "</style></svg>");

    GError* error = NULL;
    g_test_expect_message("librsvg", G_LOG_LEVEL_WARNING, "*CSS buffer too large*");
    RsvgHandle* handle = rsvg_handle_new_from_data((const guint8*)svg->str, svg->len, &error);
    g_test_assert_expected_messages();

    g_assert_no_error(error);
    g_assert_nonnull(handle);

    g_object_unref(handle);
    g_string_free(svg, TRUE);
    g_free(css);
}

int main(int argc, char** argv) {
    g_test_init(&argc, &argv, NULL);
    g_test_add_func("/security/metadata-injection", test_metadata_injection);
    g_test_add_func("/security/instancing-limit", test_instancing_limit);
    g_test_add_func("/security/css-size-limit", test_css_size_limit);
    return g_test_run();
}
